/******************************************/
/* THE WEIGHT 3 MODULAR COMPLEX OF Y_1(N) */
/******************************************/

/*

Author: Fran√ßois Brunault
Date: May 2023

To use this program, you should start PARI/GP in the
directory containing this file, and type the command

\r K4-modular-complex.gp

This program is a (partial) implementation of the
weight 3 modular complex C_N(3) of Y_1(N) introduced
in Section 3 of the paper

[B23] F. Brunault, On the Mahler measure of (1+x)(1+y)+z

This program can be used to express Lalin's class xi_E
in terms of the xi_1(a,b) [B23, Section 4]. Namely, type

find_xi1ab(15, Lalin_cocycle())

or

find_xi1ab(15, Lalin_cocycle(), [[1, 4]])

More generally, the function find_xi1ab can be used to
(try to) express a degree 2 cocycle in C_N(3) as a linear
combination of the xi_1(a,b) modulo coboundaries.
Please see the description of the function find_xi1ab
below for more details.

*/


/*********************************************/
/* INITIALISING DATA FOR COMPUTING IN C_N(3) */
/*********************************************/


\\ Residue of x or -x mod N which is in [0, N/2]

{
red(x, N) =
  my(t = x%N);
  if(t <= N\2, t, N-t);
}

\\ Express the modular unit u_1(a,b,c,d) in the basis
\\ of Siegel units g_{0,k} with 1 <= k <= N/2.
\\ The integers a, b, c, d must be in [0, N/2] and distinct.

{
u1_to_g(N, abcd) =
  my([a, b, c, d] = abcd, v = vector(N\2));
  v[red(c+a, N)] += 1;
  v[red(c-a, N)] += 1;
  v[red(d+b, N)] += 1;
  v[red(d-b, N)] += 1;
  v[red(c+b, N)] -= 1;
  v[red(c-b, N)] -= 1;
  v[red(d+a, N)] -= 1;
  v[red(d-a, N)] -= 1;
  v;
}

\\ Initialise data to compute in C_N(3)

{
u_data(N) =
  my(L = [], V1 = [], V2 = [], Lall = [], Vall = [], a, b, c, d, X);
  forvec(abcd = vector(4, i, [0, N\2]),
    [a, b, c, d] = abcd;
    X = u1_to_g(N, [a, b, c, d]);
    \\ Check if we already know the modular unit
    \\ u_1(a,b,c,d) modulo u -> 1/u and u -> 1-u
    for(i = 1, #L,
      if(X == V1[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, 1]]);
        next(2));
      if(X == -V1[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, -1]]);
        next(2));
      if(X == V2[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, -1]]);
        next(2));
      if(X == -V2[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, 1]]);
        next(2));
      if(X == V2[i]-V1[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, 1]]);
        next(2));
      if(X == V1[i]-V2[i],
        Lall = concat(Lall, [abcd]);
        Vall = concat(Vall, [[i, -1]]);
        next(2)));
    \\ Case the unit u_1(a,b,c,d) is new to us
    L = concat(L, [abcd]);
    V1 = concat(V1, [X]);
    V2 = concat(V2, [u1_to_g(N, [a, c, b, d])]);
    Lall = concat(Lall, [abcd]);
    Vall = concat(Vall, [[#L, 1]]),
    2);
  [L, V1, V2, Lall, Vall];
}


/***********************************/
/* GENERATING THE 5-TERM RELATIONS */
/***********************************/


\\  The function rel5terms creates the subspace R'_2
\\  of Q[U'_2] generated by the 5-term relations
\\  (see [B23, Section 3]).
\\
\\  Input:
\\
\\  * the level N
\\  * the vector Udata, obtained using u_data(N)
\\
\\  Output:
\\
\\  a matrix whose columns are the 5-term relations
\\  expressed in the basis given by Udata.

{
rel5terms(N, Udata = u_data(N)) =
  my(len = #Udata[1], Lall = Udata[4], Vall = Udata[5], Rels5, t = 1, rel, abcd, j, v);
  Rels5 = matrix(len, binomial(1+(N\2), 5));
  forvec(A = vector(5, i, [0, N\2]),
    \\ A = {0 <= a_1 < a_2 < ... < a_5 <= N/2}
    \\ 5-term relation associated to A
    rel = vectorv(len);
    for(i = 1, 5,
      \\ We remove the i-th component of A
      abcd = concat(A[1..(i-1)], A[(i+1)..5]);
      \\ Search for u_1(a,b,c,d) in the list Lall
      j = vecsearch(Lall, abcd);
      if(j == 0, error("u_1(a,b,c,d) not found in Lall"));
      v = Vall[j];
      rel[v[1]] += (-1)^i * v[2]);
    \\ Write the relation rel in the matrix Rels5
    Rels5[, t] = rel;
    t += 1,
    2);
  Rels5;
}

\\  The function tensor(X, Y) computes the tensor product
\\  of two vectors X and Y. The output is the vector
\\
\\  T = [X[1]*Y[1], X[2]*Y[1], X[3]*Y[1]...,
\\        X[1]*Y[2], X[2]*Y[2], X[3]*Y[2]...]
\\
\\  The type of T (row/column) is the same as that of X.

{
tensor(X, Y) =
  concat(vector(#Y, k, Y[k]*X));
}


/***************************/
/* ADDING THE COBOUNDARIES */
/***************************/


\\  In the notations of [B23, Section 3], the
\\  function relations(N) creates the subspace
\\  (R'_2 \otimes <U_1>) + Q' inside the tensor
\\  product space Q[U'_2] \otimes <U_1>, where:
\\
\\  * R'_2 is the subspace of Q[U'_2] created by
\\    rel5terms(N)
\\  * Q' is the space of degree 2 coboundaries
\\
\\  The output is a matrix whose columns generate
\\  the above subspace.

{
relations(N, Udata = u_data(N)) =
  my(len = #Udata[1], R5, Rels, l = 1, rel5, rel0, rel, u, v0);
  \\ 5-term relations
  R5 = rel5terms(N, Udata);
  R5 = matimage(R5);
  Rels = matrix(len * (N\2), matsize(R5)[2] * (N\2) + 2*len);
  for(j1 = 1, matsize(R5)[2],
    \\ We tensor the relation R5[,j1]
    \\ with each Siegel unit g_{0,k}
    rel5 = R5[,j1];
    rel0 = vector(N\2, j2, vectorv(len));
    for(j2 = 1, N\2,
      rel = rel0;
      rel[j2] = rel5;
      Rels[,l] = concat(rel);
      l += 1));
  \\ Coboundaries
  for(i = 1, len,
    \\ Coboundary [u] \otimes u
    v0 = vectorv(len);
    v0[i] = 1;
    rel = tensor(v0, Udata[2][i]);  \\ u = Udata[2][i]
    Rels[,l] = rel;
    l += 1;
    \\ Coboundary [u] \otimes (1-u)
    rel = tensor(v0, Udata[3][i]);  \\ 1-u = Udata[3][i]
    Rels[,l] = rel;
    l += 1);
  Rels;
}


/*************************/
/* THE CLASSES xi_1(a,b) */
/*************************/


\\ The function u1_abcd gives the coordinates of
\\ {u_1(a,b,c,d)}_2 in the space Q[U'_2].

{
u1_abcd(N, abcd, Udata = u_data(N)) =
  my(len = #Udata[1], Lall = Udata[4], Vall = Udata[5], z = vectorv(len), s, j, v);
  abcd = apply(x -> red(x, N), abcd);
  s = vecsort(abcd, , 9);
  if(#s < 4,
    return(z));
  abcd = vecextract(abcd, s);
  \\ Search for u_1(a,b,c,d) in the list Lall
  j = vecsearch(Lall, abcd);
  if(j == 0, error("u_1(a,b,c,d) not found in Lall"));
  v = Vall[j];
  z[v[1]] = permsign(s) * v[2];
  z;
}

\\  Triangulation of the 3-term relation in K_2(Y_1(N))
\\
\\  (See Sections 4 and 6 of [Brunault, On the K_4 group
\\  of modular curves, arXiv:2009.07614].)
\\  
\\  Input:
\\
\\  * the level N
\\  * the parameters a, b in Z/NZ
\\
\\  Output:
\\
\\  the triangulation as an element of Q[U'_2],
\\  normalised as
\\  
\\  \sum_{x in Z/NZ} {u_1(0, x, a-x, b+x)}_2
\\  (+ supplementary terms for N even)

{
triangulation(N, a, b, Udata = u_data(N)) =
  my(z = vectorv(#Udata[1]), c);
  for(x = 0, N-1,
    z += u1_abcd(N, [0, x, a-x, b+x], Udata));
  if(N%2 == 0,
    \\ Supplementary terms for N even
    c = -a-b;
    for(x = 0, N-1,
      for(y = 0, N-1,
        z += (-1/(4*N)) * (u1_abcd(N, [0, a, c+2*x, y], Udata) + u1_abcd(N, [0, c, b+2*x, y], Udata) + u1_abcd(N, [0, b, a+2*x, y], Udata)))));
  z;
}

\\ The function xi1(N, [a, b], Udata) returns
\\ the cocycle xi_1(a,b) written in the basis
\\ of Q[U'_2] \otimes <U_1> given by Udata.

{
xi1(N, ab, Udata = u_data(N)) =
  my([a, b] = ab, T, g);
  \\ Triangulation of g_a ^ g_b + g_b ^ g_c + g_c ^ g_a
  T = triangulation(N, a, b, Udata);
  \\ Modular unit g_{0,b} / g_{0,a}
  a = red(a, N);
  b = red(b, N);
  g = vector(N\2);
  if(b != 0,
    g[b] += 1);
  if(a != 0,
    g[a] -= 1);
  tensor(T, g);
}


/*****************/
/* MAIN FUNCTION */
/*****************/


\\  The function find_xi1ab attempts to express a
\\  degree 2 cochain in C_N(3) as a linear combination
\\  of the xi_1(a,b), plus some coboundaries.
\\
\\  Input:
\\
\\  * the level N
\\  * a degree 2 cochain xi, given as a vector in
\\    the tensor product Q[U'_2] \otimes <U_1>
\\  * a vector 'indices', containing the elements
\\    [a, b] to use. If this argument is not given,
\\    the function takes all the [a, b] with
\\    1 <= a < b <= N/2.
\\
\\  Output:
\\
\\  a vector of 2-component vectors [n, [a, b]],
\\  which means that xi is equal to
\\
\\  \sum n * xi_1(a,b)
\\
\\  modulo the coboundaries. If nothing is found,
\\  the function returns -1 (this does not prove
\\  that the class of xi is not a linear combination
\\  of the classes xi_1(a,b)).

{
find_xi1ab(N, xi, indices) =
  my(Udata = u_data(N), Rels = relations(N, Udata), Cocycles, M, Sol, Sol2 = []);
  if(indices == 0,
    indices = [];
    for(a = 1, N\2,
      for(b = a+1, N\2,
        indices = concat(indices, [[a, b]]))));
  Cocycles = matrix(matsize(Rels)[1], #indices);
  for(k = 1, #indices,
    Cocycles[,k] = xi1(N, indices[k], Udata));
  M = matconcat([Rels, Cocycles]);
  Sol = matinverseimage(M, xi);
  if(Sol == []~,
    return(-1));
  Sol = N * vecextract(Sol, [#Sol-#indices+1..#Sol]);
  for(i = 1, #indices,
    if(Sol[i] != 0,
      Sol2 = concat(Sol2, [[Sol[i], indices[i]]])));
  Sol2;
}


/*********************/
/* THE LALIN COCYCLE */
/*********************/


\\ Lalin's cocycle \xi_E, viewed in X_1(15)

{
Lalin_cocycle() =
  my(N = 15, Udata = u_data(N), X, Y);
  \\ X = {-x}_2
  X = u1_abcd(N, [1, 2, 3, 7], Udata);
  \\ Y = {-y}_2
  Y = u1_abcd(N, [2, 4, 6, 1], Udata);
  tensor(X, u1_to_g(N, [2, 4, 6, 1])) - tensor(Y, u1_to_g(N, [1, 2, 3, 7]));
}
